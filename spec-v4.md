# Zero-Runtime CSS Engine: Taikocss — Spec 4: Packaging & Distribution

This document specifies everything needed to turn the v2 codebase into a
properly publishable npm package that external projects can install and use
without any manual setup.

---

## 1. Current state summary

The v2 codebase is a working monolith: the Rust binary, the Vite plugin, the
TypeScript types, and the runtime shim all live together in one directory. The
following problems prevent external use:

| Problem | Impact |
|---|---|
| `vite.config.js` is a config file, not a module | `import from 'my-css-engine/vite'` imports the whole Vite config, not just the plugin |
| No `"./css"` export for the runtime shim | Consumers must create their own shim manually |
| No prebuilt platform binaries | Consumers need Rust toolchain to build from source |
| No CI/release pipeline | Publishing is manual and error-prone |
| No version strategy or changelog | Breaking changes are invisible to consumers |
| `package.json` exports map is incomplete | TypeScript can't resolve types for all entry points |
| No `peerDependencies` version enforcement | Silent breakage when used with unsupported Vite versions |
| No install-time binary selection | Wrong binary is loaded on mismatched platform |

---

## 2. File structure after this spec

```
my-css-engine/
├── src/
│   └── css.ts                  # runtime shim (no-op)
├── plugin.js                   # Vite plugin entry point (replaces vite.config.js)
├── plugin.d.ts                 # hand-written types for the plugin (replaces types/vite.d.ts)
├── index.js                    # NAPI-RS generated binary loader
├── index.d.ts                  # NAPI-RS generated + extended types
├── types/
│   ├── css.d.ts                # css(), CSSProperties, globalCss, keyframes, container
│   └── theme.d.ts              # Theme interface (v3 ready)
├── npm/                        # per-platform binary packages (auto-generated by napi)
│   ├── darwin-arm64/
│   ├── darwin-x64/
│   ├── linux-x64-gnu/
│   ├── linux-arm64-gnu/
│   └── win32-x64-msvc/
├── scripts/
│   └── check-platform.js       # install-time script — warns on unsupported platforms
├── Cargo.toml
├── Cargo.lock                  # committed — ensures reproducible binary builds
├── build.rs
├── lib.rs
├── package.json
├── README.md
├── CHANGELOG.md
└── .github/
    └── workflows/
        ├── ci.yml              # test on every PR
        └── release.yml         # build + publish on git tag
```

---

## 3. Entry point refactor

### 3.1 Extract the Vite plugin into `plugin.js`

Create `plugin.js` as a standalone ES module that exports only the plugin
factory. Remove the `export default { plugins: [...] }` wrapper that made this
a config file rather than a library.

```js
// plugin.js
import { createRequire } from 'module'

const require = createRequire(import.meta.url)

/**
 * Load the native binary. We try the local build first (for contributors
 * working in the repo) and fall back to the platform-specific npm package.
 */
function loadNative() {
  // 1. Local build (repo contributors / debug builds)
  try {
    return require('./index.js')
  } catch {}

  // 2. Platform-specific package (installed consumers)
  const platform = `${process.platform}-${process.arch}`
  try {
    return require(`@my-css-engine/core-${platform}`)
  } catch (e) {
    throw new Error(
      `my-css-engine: no prebuilt binary found for ${platform}.\n` +
      `If you are on a supported platform, try reinstalling.\n` +
      `Supported platforms: darwin-arm64, darwin-x64, linux-x64-gnu, ` +
      `linux-arm64-gnu, win32-x64-msvc.\n` +
      `Original error: ${e.message}`
    )
  }
}

const { transform } = loadNative()

// Maps virtual module ID → { css, map }
const cssMap = new Map()

// Maps source file path → Set<virtualModuleId>
const fileToVids = new Map()

/**
 * Create the zero-runtime CSS Vite plugin.
 *
 * @param {import('./plugin').PigmentOptions} [options]
 * @returns {import('vite').Plugin}
 */
export function pigment(options = {}) {
  const themeJson = options.theme
    ? JSON.stringify(options.theme)
    : undefined

  return {
    name: 'my-css-engine',
    enforce: 'pre',

    transform(code, id) {
      if (!/\.(t|j)sx?$/.test(id) || id.includes('node_modules')) return
      if (!code.includes('css(') && !code.includes('globalCss') && !code.includes('keyframes')) return

      let result
      try {
        result = transform(id, code, themeJson ?? null)
      } catch (err) {
        this.error(err.message)
      }

      if (!result.cssRules.length && !result.globalCss?.length && !result.keyframes?.length) return

      let imports = ''

      // Global CSS — injected before component CSS
      for (const rule of result.globalCss ?? []) {
        const vid = `virtual:my-css-engine/global-${rule.hash}.css`
        if (!cssMap.has(vid)) {
          cssMap.set(vid, { css: rule.css, map: rule.map ?? null })
          imports += `import "${vid}";\n`
        }
        if (!fileToVids.has(id)) fileToVids.set(id, new Set())
        fileToVids.get(id).add(vid)
      }

      // Keyframes
      for (const kf of result.keyframes ?? []) {
        const vid = `virtual:my-css-engine/kf-${kf.hash}.css`
        if (!cssMap.has(vid)) {
          cssMap.set(vid, { css: kf.css, map: kf.map ?? null })
          imports += `import "${vid}";\n`
        }
        if (!fileToVids.has(id)) fileToVids.set(id, new Set())
        fileToVids.get(id).add(vid)
      }

      // Component CSS rules
      for (const rule of result.cssRules) {
        const vid = `virtual:my-css-engine/${rule.hash}.css`
        if (!cssMap.has(vid)) {
          cssMap.set(vid, { css: rule.css, map: rule.map ?? null })
          imports += `import "${vid}";\n`
        }
        if (!fileToVids.has(id)) fileToVids.set(id, new Set())
        fileToVids.get(id).add(vid)
      }

      return {
        code: imports + result.code,
        map: result.map ?? null,
      }
    },

    resolveId(id) {
      if (id.startsWith('virtual:my-css-engine/')) return id
    },

    load(id) {
      if (!id.startsWith('virtual:my-css-engine/')) return
      const entry = cssMap.get(id)
      if (!entry) return
      if (entry.map) {
        const b64 = Buffer.from(entry.map).toString('base64')
        return entry.css + `\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,${b64} */`
      }
      return entry.css
    },

    handleHotUpdate({ file, server }) {
      const vids = fileToVids.get(file)
      if (!vids || vids.size === 0) return

      const affectedMods = []
      for (const vid of vids) {
        cssMap.delete(vid)
        const mod = server.moduleGraph.getModuleById(vid)
        if (mod) affectedMods.push(mod)
      }
      fileToVids.delete(file)
      if (affectedMods.length === 0) return
      for (const mod of affectedMods) server.moduleGraph.invalidateModule(mod)
      return affectedMods
    },
  }
}

// Backwards-compatible export — deprecated, use pigment() instead
export const rustCssPlugin = pigment()
```

### 3.2 The runtime shim as a package export

Move `src/css.ts` into the package itself so consumers don't have to create
their own:

```ts
// src/css.ts (shipped in the package, not just the repo)
export function css(_styles: Record<string, unknown>): string { return '' }
export function globalCss(_strings: TemplateStringsArray, ..._values: unknown[]): void {}
export function keyframes(_strings: TemplateStringsArray, ..._values: unknown[]): string { return '' }
export function container(..._args: unknown[]): Record<string, unknown> { return {} }
```

This is the file that Jest/Vitest-node/ts-node will resolve when the Vite
plugin is not in the pipeline.

---

## 4. `package.json` — complete rewrite

```json
{
  "name": "my-css-engine",
  "version": "0.2.0",
  "description": "Zero-runtime CSS-in-JS extraction via Rust, OXC, and LightningCSS",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/your-org/my-css-engine.git"
  },

  "type": "module",
  "main": "./index.cjs",
  "module": "./index.js",

  "exports": {
    ".": {
      "types":   "./index.d.ts",
      "import":  "./index.js",
      "require": "./index.cjs"
    },
    "./vite": {
      "types":   "./plugin.d.ts",
      "import":  "./plugin.js",
      "require": "./plugin.cjs"
    },
    "./css": {
      "types":   "./types/css.d.ts",
      "import":  "./src/css.js",
      "require": "./src/css.cjs"
    }
  },

  "files": [
    "index.js",
    "index.cjs",
    "index.d.ts",
    "plugin.js",
    "plugin.cjs",
    "plugin.d.ts",
    "src/css.js",
    "src/css.cjs",
    "src/css.d.ts",
    "types/",
    "README.md",
    "CHANGELOG.md"
  ],

  "scripts": {
    "build":           "napi build --platform --release",
    "build:debug":     "napi build --platform",
    "prepublishOnly":  "npm run build",
    "test":            "node test.mjs",
    "typecheck":       "tsc --noEmit",
    "changeset":       "changeset",
    "version":         "changeset version && npm install --package-lock-only",
    "release":         "changeset publish"
  },

  "napi": {
    "binaryName": "my-css-engine",
    "packageName": "@my-css-engine/core",
    "targets": [
      "aarch64-apple-darwin",
      "x86_64-apple-darwin",
      "x86_64-pc-windows-msvc",
      "x86_64-unknown-linux-gnu",
      "aarch64-unknown-linux-gnu"
    ]
  },

  "peerDependencies": {
    "vite": "^4.0.0 || ^5.0.0 || ^6.0.0"
  },
  "peerDependenciesMeta": {
    "vite": { "optional": true }
  },

  "devDependencies": {
    "@changesets/cli":  "^2.27.0",
    "@napi-rs/cli":     "^3.5.1",
    "typescript":       "^5.4.0",
    "vite":             "^6.0.0"
  },

  "optionalDependencies": {
    "@my-css-engine/core-darwin-arm64":   "0.2.0",
    "@my-css-engine/core-darwin-x64":     "0.2.0",
    "@my-css-engine/core-linux-x64-gnu":  "0.2.0",
    "@my-css-engine/core-linux-arm64-gnu":"0.2.0",
    "@my-css-engine/core-win32-x64-msvc": "0.2.0"
  },

  "engines": {
    "node": ">=18.0.0"
  }
}
```

**Key decisions explained:**

`"type": "module"` — the package is ESM-first. CJS variants (`.cjs`) are
generated for tooling that doesn't yet support ESM (older Jest configs, some
bundlers). Both are listed under `exports` so Node.js picks the right one
automatically.

`optionalDependencies` — each platform binary is a separate optional package.
npm/pnpm/yarn will install only the one matching the current platform and skip
the rest silently. This avoids forcing consumers to download 5× the binary
weight.

`vite` as an optional peer — required only for the `./vite` entry point.
Projects that use only the runtime shim (pure Jest setups) don't need Vite
installed.

`"files"` — explicit allowlist ensures `lib.rs`, `.node` binaries in the repo
root, test files, and build artefacts are never accidentally published.

---

## 5. Per-platform binary packages

NAPI-RS's `napi build --platform` command generates separate `npm/<platform>/`
directories each containing:
- `package.json` with the platform-specific package name
- The compiled `.node` binary
- A minimal `index.js` loader

These packages are published to npm under scoped names:

```
@my-css-engine/core-darwin-arm64
@my-css-engine/core-darwin-x64
@my-css-engine/core-linux-x64-gnu
@my-css-engine/core-linux-arm64-gnu
@my-css-engine/core-win32-x64-msvc
```

Each has a `package.json` like:

```json
{
  "name": "@my-css-engine/core-darwin-arm64",
  "version": "0.2.0",
  "description": "my-css-engine native binary for darwin-arm64",
  "os":   ["darwin"],
  "cpu":  ["arm64"],
  "main": "my-css-engine.darwin-arm64.node",
  "files": ["my-css-engine.darwin-arm64.node"]
}
```

npm uses the `os` and `cpu` fields to skip installation on non-matching
platforms, so `npm install my-css-engine` on a Linux x64 machine downloads
only `@my-css-engine/core-linux-x64-gnu`.

---

## 6. Binary loading strategy in `index.js`

The generated `index.js` (from NAPI-RS) already handles this, but the loading
strategy should be documented and explicit. The load order is:

1. Try `./my-css-engine.<platform>.node` — present in the repo after a local
   `npm run build`. Works for contributors.
2. Try `@my-css-engine/core-<platform>` — present after `npm install` in a
   consumer project. Works for end users.
3. Throw a descriptive error listing the supported platforms and suggesting
   reinstallation.

This is handled by NAPI-RS's generated loader. No manual code needed unless
customising the error message (see `plugin.js` section 3.1 above).

---

## 7. TypeScript configuration

### 7.1 `tsconfig.json`

```json
{
  "compilerOptions": {
    "target":           "ES2020",
    "module":           "NodeNext",
    "moduleResolution": "NodeNext",
    "lib":              ["ES2020", "DOM"],
    "strict":           true,
    "declaration":      true,
    "declarationMap":   true,
    "outDir":           "./dist-types",
    "rootDir":          "./",
    "skipLibCheck":     true
  },
  "include": ["types/**/*", "src/**/*"],
  "exclude": ["node_modules", "npm"]
}
```

### 7.2 `plugin.d.ts`

Replaces `types/vite.d.ts`. Positioned at the root so the `"./vite"` export
can point directly at it:

```ts
// plugin.d.ts
import type { Plugin } from 'vite'
import type { Theme }  from './types/theme'

export interface PigmentOptions {
  /**
   * Design token theme. Passed to css(({ theme }) => …) calls at build time.
   * The theme object is never shipped to the browser.
   */
  theme?: Theme

  css?: {
    /** @default 'ltr' */
    defaultDirection?: 'ltr' | 'rtl'
    /** @default false */
    generateForBothDir?: boolean
  }
}

/**
 * Create the zero-runtime CSS Vite plugin.
 *
 * @example
 * // vite.config.ts
 * import { pigment } from 'my-css-engine/vite'
 * export default { plugins: [pigment({ theme: myTheme })] }
 */
export declare function pigment(options?: PigmentOptions): Plugin

/**
 * @deprecated Use pigment() instead.
 */
export declare const rustCssPlugin: Plugin
```

---

## 8. Install-time platform check

Add a `postinstall` script that warns (not errors) when the current platform
has no prebuilt binary. This surfaces the problem immediately rather than at
first use.

```js
// scripts/check-platform.js
const supported = [
  'darwin-arm64',
  'darwin-x64',
  'linux-x64',
  'linux-arm64',
  'win32-x64',
]

const current = `${process.platform}-${process.arch}`
const ok = supported.some(p => current.startsWith(p))

if (!ok) {
  console.warn(
    `\nmy-css-engine: no prebuilt binary available for ${current}.\n` +
    `Supported platforms: ${supported.join(', ')}.\n` +
    `You will need to build from source: npm run build\n` +
    `(Requires Rust: https://rustup.rs)\n`
  )
}
```

Add to `package.json`:

```json
"scripts": {
  "postinstall": "node scripts/check-platform.js"
}
```

This script must never throw — a failing `postinstall` blocks the entire
install. Wrap the body in a `try/catch` that silently exits if anything goes
wrong.

---

## 9. CI pipeline — `ci.yml`

Runs on every pull request and push to `main`. Validates that the package
builds and all tests pass on all supported platforms.

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    name: Test — ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node: ['18', '20', '22']

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
          cache: npm

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust build artefacts
        uses: Swatinem/rust-cache@v2

      - name: Install dependencies
        run: npm ci

      - name: Build native binary (debug)
        run: npm run build:debug

      - name: Run tests
        run: npm test

  typecheck:
    name: TypeScript
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20', cache: npm }
      - run: npm ci
      - run: npm run typecheck
```

---

## 10. Release pipeline — `release.yml`

Triggered by pushing a git tag matching `v*.*.*`. Builds the native binary for
every platform in parallel using GitHub's matrix strategy (each runner is a
different OS/architecture), then publishes all platform packages and the root
package to npm in a single step.

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags: ['v*.*.*']

jobs:
  # ── Build one binary per platform ──────────────────────────────────────────
  build:
    name: Build — ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            os:     macos-latest
          - target: x86_64-apple-darwin
            os:     macos-latest
          - target: x86_64-unknown-linux-gnu
            os:     ubuntu-latest
          - target: aarch64-unknown-linux-gnu
            os:     ubuntu-latest
            packages: gcc-aarch64-linux-gnu
          - target: x86_64-pc-windows-msvc
            os:     windows-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with: { node-version: '20', cache: npm }

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.target }}

      - name: Install cross-compile toolchain (Linux ARM64 only)
        if: matrix.packages
        run: sudo apt-get install -y ${{ matrix.packages }}

      - name: Install dependencies
        run: npm ci

      - name: Build release binary
        run: npx napi build --platform --release --target ${{ matrix.target }}

      - name: Upload binary artefact
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.target }}
          path: |
            *.node
            npm/${{ matrix.target }}/*.node

  # ── Publish all packages to npm ────────────────────────────────────────────
  publish:
    name: Publish to npm
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci

      - name: Download all binary artefacts
        uses: actions/download-artifact@v4
        with:
          pattern: binary-*
          merge-multiple: true

      - name: List downloaded files (sanity check)
        run: find . -name '*.node' | sort

      - name: Publish platform packages
        run: npx napi prepublish --skip-gh-release
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Publish root package
        run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

### Required GitHub secrets

| Secret | Value |
|---|---|
| `NPM_TOKEN` | An npm Automation token with publish rights to the `@my-css-engine` scope and the `my-css-engine` package |

### Publishing the npm scope

Before the first release, the `@my-css-engine` scope must exist on npm:

```bash
npm login
npm org create my-css-engine   # or use the npm website
```

---

## 11. Versioning strategy

Use [Changesets](https://github.com/changesets/changesets) for version
management. It enforces semantic versioning, generates changelogs, and
coordinates publishing of multiple packages (the root package and the 5
platform packages must all be released at the same version).

### Setup

```bash
npm install --save-dev @changesets/cli
npx changeset init
```

### `.changeset/config.json`

```json
{
  "$schema": "https://unpkg.com/@changesets/config@3.0.0/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [
    [
      "my-css-engine",
      "@my-css-engine/core-darwin-arm64",
      "@my-css-engine/core-darwin-x64",
      "@my-css-engine/core-linux-x64-gnu",
      "@my-css-engine/core-linux-arm64-gnu",
      "@my-css-engine/core-win32-x64-msvc"
    ]
  ],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}
```

The `"fixed"` array keeps all packages locked to the same version — essential
because the root package's `optionalDependencies` pins exact versions of the
platform packages.

### Workflow for a release

```bash
# 1. After merging one or more PRs, describe the changes
npx changeset

# 2. Commit the changeset file along with the change
git add .changeset/
git commit -m "chore: add changeset"

# 3. When ready to release, bump versions and update CHANGELOG.md
npx changeset version
git add -A && git commit -m "chore: release v0.2.1"

# 4. Tag and push — the release workflow fires automatically
git tag v0.2.1
git push && git push --tags
```

---

## 12. CHANGELOG.md — initial entry

```markdown
# Changelog

## 0.2.0 — Initial public release

### Features

- `css({})` — zero-runtime class name extraction with LightningCSS minification
- `css(({ theme }) => ({}))` — build-time theme token resolution
- `globalCss\`…\`` — global style injection via tagged template literals
- `keyframes\`…\`` — hashed `@keyframes` animation names
- `container()` — compile-time containment context helper
- `@container` query support in `css()` objects
- V3 source maps for both JS (via oxc_codegen) and CSS (via parcel_sourcemap)
- HMR with precise virtual module invalidation
- Rich error messages with file, line, and column
- Prebuilt binaries for macOS (ARM64, x64), Linux (x64, ARM64), Windows (x64)

### Breaking changes

None — this is the first public release.
```

---

## 13. Consumer usage after publishing

Once published, a consumer project sets up as follows.

### Install

```bash
npm install my-css-engine
```

### Configure Vite

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import { pigment } from 'my-css-engine/vite'
import { myTheme } from './src/theme'

export default defineConfig({
  plugins: [pigment({ theme: myTheme })],
})
```

### Use in components

```ts
// src/Button.tsx
import { css } from 'my-css-engine/css'

const button = css({
  backgroundColor: 'tomato',
  borderRadius: 4,
  padding: '8px 16px',
})
```

Note: consumers import from `my-css-engine/css` — the `"./css"` entry point.
This resolves to the runtime shim in test/SSR environments and is replaced at
build time by the Vite plugin. No manual shim creation required.

### Configure Jest

```js
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  moduleNameMapper: {
    // The ./css entry resolves to the shim — no styles, no crashes
    '^my-css-engine/css$': 'my-css-engine/css',
    // The root entry is unused in tests, but map it too for safety
    '^my-css-engine$':     'my-css-engine/css',
  },
}
```

Because `my-css-engine/css` is a proper package export pointing at the
compiled shim, Jest resolves it through the `exports` map automatically. No
path hacks needed.

### Configure Vitest

```ts
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import { pigment } from 'my-css-engine/vite'

export default defineConfig({
  plugins: [pigment()],
  test: { environment: 'jsdom' },
})
```

---

## 14. Local development of the package itself

For contributors working on the engine, and for testing integration before
publishing:

```bash
# In the my-css-engine repo
npm run build          # compile the native binary
npm link               # register the package globally

# In an external project
npm link my-css-engine # use the local version
```

Or with a direct path in the consumer's `package.json`:

```json
{
  "dependencies": {
    "my-css-engine": "file:../path/to/my-css-engine"
  }
}
```

---

## 15. Test additions for the distribution layer

Add the following tests to `test.mjs` to validate the packaging itself works
correctly before publishing:

| Test | Assertion |
|---|---|
| `require('my-css-engine')` (CJS) | Loads without error, `transform` is a function |
| `import 'my-css-engine'` (ESM) | Loads without error |
| `import 'my-css-engine/css'` | Exports `css`, `globalCss`, `keyframes`, `container` functions |
| `import 'my-css-engine/vite'` | Exports `pigment` function and `rustCssPlugin` object |
| `pigment()` return value | Has `name`, `enforce`, `transform`, `resolveId`, `load`, `handleHotUpdate` |
| `pigment({ theme })` | Passes theme JSON to Rust `transform()` call |
| Unsupported platform | `loadNative()` throws a message that includes the platform name and a reinstall hint |
| `postinstall` script | Exits with code 0 on supported platforms, prints warning (not error) on unsupported |

---

## 16. Priority order

1. **Entry point refactor** (section 3) — unblocks everything else; one afternoon of work
2. **`package.json` rewrite** (section 4) — exports map, optionalDependencies, files allowlist
3. **`plugin.d.ts`** (section 7.2) — unblocks TypeScript consumers of `./vite`
4. **Runtime shim as a package export** (section 3.2) — removes the manual shim requirement
5. **CI pipeline** (section 9) — validates correctness on all platforms before publish
6. **Changesets setup** (section 11) — must be in place before the first `npm publish`
7. **Release pipeline** (section 10) — automates the cross-compile + publish flow
8. **Install-time platform check** (section 8) — polish; add last
9. **Distribution layer tests** (section 15) — add alongside each item above