import { createRequire } from 'module'
const require = createRequire(import.meta.url)
// index.js is a CJS file generated by NAPI-RS. Because package.json sets
// "type":"module", Node would parse .js as ESM. loader.cjs forces CJS context.
const { transform } = require('./loader.cjs')

// ─── helpers ────────────────────────────────────────────────────────────────

let passed = 0
let failed = 0
const pending = []

function test(name, fn) {
  try {
    const result = fn()
    if (result && typeof result.then === 'function') {
      pending.push(
        result.then(() => {
          console.log(`  ✓ ${name}`)
          passed++
        }).catch((e) => {
          console.error(`  ✗ ${name}`)
          console.error(`    ${e.message}`)
          failed++
        })
      )
    } else {
      console.log(`  ✓ ${name}`)
      passed++
    }
  } catch (e) {
    console.error(`  ✗ ${name}`)
    console.error(`    ${e.message}`)
    failed++
  }
}

function assert(condition, msg) {
  if (!condition) throw new Error(msg ?? 'assertion failed')
}

function assertThrows(fn, match, label) {
  try {
    fn()
    throw new Error(`${label ?? 'expected throw'} — no error was thrown`)
  } catch (e) {
    if (typeof match === 'string') {
      assert(e.message.includes(match), `error "${e.message}" did not include "${match}"`)
    } else {
      assert(match.test(e.message), `error "${e.message}" did not match ${match}`)
    }
  }
}

// ─── v2 tests (unchanged) ────────────────────────────────────────────────────

console.log('\n── Basic extraction ───────────────────────────────────────────')

test('replaces css({}) call with a string literal', () => {
  const { code } = transform('test.jsx', `const btn = css({ color: 'red' })`)
  assert(code.includes('"cls_'), `expected cls_ class name, got: ${code}`)
  assert(!code.includes('css({'), `css() call should be gone, got: ${code}`)
})

test('returns a css rule', () => {
  const { cssRules } = transform('test.jsx', `const btn = css({ color: 'red' })`)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('red'), `expected color:red in css, got: ${cssRules[0].css}`)
  assert(cssRules[0].hash.length > 0, 'hash should be non-empty')
})

test('camelCase → kebab-case', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ backgroundColor: 'blue' })`)
  assert(cssRules[0].css.includes('background-color'), `got: ${cssRules[0].css}`)
})

test('numeric value gets px suffix', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ padding: 16 })`)
  assert(cssRules[0].css.includes('16px'), `got: ${cssRules[0].css}`)
})

test('unitless numeric (opacity) gets no px', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ opacity: 0.5 })`)
  assert(!cssRules[0].css.includes('px'), `got: ${cssRules[0].css}`)
  assert(cssRules[0].css.includes('.5'), `got: ${cssRules[0].css}`)
})

test('unitless numeric (fontWeight) gets no px', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ fontWeight: 700 })`)
  assert(!cssRules[0].css.includes('px'), `got: ${cssRules[0].css}`)
})

console.log('\n── Nesting & media queries ────────────────────────────────────')

test('&:hover nesting', () => {
  const { cssRules } = transform('test.jsx', `
    const x = css({ color: 'red', '&:hover': { color: 'blue' } })
  `)
  assert(cssRules.length >= 1, 'expected at least 1 rule')
  const allCss = cssRules.map(r => r.css).join('')
  assert(allCss.includes(':hover'), `expected :hover, got: ${allCss}`)
})

test('@media query', () => {
  const { cssRules } = transform('test.jsx', `
    const x = css({ padding: '8px', '@media (max-width: 600px)': { padding: '4px' } })
  `)
  const allCss = cssRules.map(r => r.css).join('')
  assert(allCss.includes('@media'), `expected @media, got: ${allCss}`)
})

console.log('\n── Full component (spec example) ──────────────────────────────')

test('full Button component', () => {
  const source = `
    import { css } from './css'
    const button = css({
      backgroundColor: 'oklch(60% 0.2 250)',
      padding: '8px 16px',
      borderRadius: '4px',
      '&:hover': { backgroundColor: 'oklch(50% 0.2 250)' },
      '@media (max-width: 600px)': { padding: '4px 8px' },
    })
    export function Button() {
      return <button className={button}>Click me</button>
    }
  `
  const { code, cssRules } = transform('Button.tsx', source)
  assert(!code.includes('css({'), 'css() call should be erased')
  assert(code.includes('"cls_'), 'should have cls_ class name')
  const allCss = cssRules.map(r => r.css).join('')
  assert(allCss.includes(':hover'), 'should have :hover rule')
  assert(allCss.includes('@media'), 'should have @media rule')

  console.log('\n  Generated class name:', code.match(/"cls_\w+"/)?.[0])
  console.log('  Generated CSS:')
  for (const r of cssRules) console.log('   ', r.css)
})

console.log('\n── Edge cases ─────────────────────────────────────────────────')

test('no css() call → returns source unchanged', () => {
  const src = `const x = 1 + 2`
  const { code, cssRules } = transform('test.js', src)
  assert(code === src, 'source should be unchanged')
  assert(cssRules.length === 0, 'no rules expected')
})

test('multiple css() calls in one file', () => {
  const { code, cssRules } = transform('test.jsx', `
    const a = css({ color: 'red' })
    const b = css({ color: 'blue' })
  `)
  assert(cssRules.length === 2, `expected 2 rules, got ${cssRules.length}`)
  const hashes = cssRules.map(r => r.hash)
  assert(new Set(hashes).size === 2, 'hashes should be unique')
})

test('parse error → returns source unchanged', () => {
  const src = `const x = {{{broken`
  const { code, cssRules } = transform('test.js', src)
  assert(code === src, 'broken source should pass through unchanged')
  assert(cssRules.length === 0)
})

console.log('\n── Function body, default export, error cases ─────────────────')

test('css() inside a function body — extracted correctly', () => {
  const src = `
    function makeStyles() {
      const card = css({ padding: '16px', borderRadius: 8 })
      return card
    }
  `
  const { code, cssRules } = transform('test.jsx', src)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('padding'), `expected padding in css, got: ${cssRules[0].css}`)
  assert(!code.includes('css({'), 'css() call should be erased inside function body')
})

test('css() as a default export — extracted correctly', () => {
  const src = `export default css({ display: 'flex', alignItems: 'center' })`
  const { code, cssRules } = transform('test.jsx', src)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('flex'), `expected flex in css, got: ${cssRules[0].css}`)
  assert(!code.includes('css({'), 'css() call should be erased in default export')
  assert(code.includes('"cls_'), 'should have cls_ class name in output')
})

test('dynamic value → build error with file/line info', () => {
  const src = `
    const myColor = 'red'
    const x = css({ color: myColor })
  `
  assertThrows(
    () => transform('src/Button.tsx', src),
    /src\/Button\.tsx:\d+:\d+/,
    'dynamic value error'
  )
})

test('dynamic value error message mentions the offending identifier or property', () => {
  const src = `const x = css({ backgroundColor: someVar })`
  assertThrows(
    () => transform('test.tsx', src),
    // Error should mention either the property name or the dynamic identifier
    /backgroundColor|someVar/,
    'error should name the offending property or variable'
  )
})

test('dynamic value error message includes hint', () => {
  const src = `const x = css({ color: someVar })`
  assertThrows(
    () => transform('test.tsx', src),
    'Hint:',
    'error should include a Hint'
  )
})

test('spread in object → build error', () => {
  const src = `
    const base = { color: 'red' }
    const x = css({ ...base, padding: '8px' })
  `
  assertThrows(
    () => transform('test.tsx', src),
    /spread/i,
    'spread error'
  )
})

test('spread error includes file/line info', () => {
  const src = `const x = css({ ...base })`
  assertThrows(
    () => transform('src/Component.tsx', src),
    /src\/Component\.tsx:\d+:\d+/,
    'spread error with position'
  )
})

console.log('\n── TSX, deduplication, numerics, vendor prefixes ──────────────')

test('TSX file with type annotations — extracted correctly, types stripped', () => {
  const src = `
    import React from 'react'
    import { css } from './css'
    const styles = css({ color: 'green', fontSize: 14 })
    const MyComp: React.FC<{ label: string }> = ({ label }) => (
      <div className={styles}>{label}</div>
    )
    export default MyComp
  `
  const { code, cssRules } = transform('MyComp.tsx', src)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('green'), `expected color:green, got: ${cssRules[0].css}`)
  assert(cssRules[0].css.includes('14px'), `expected 14px, got: ${cssRules[0].css}`)
  assert(!code.includes('css({'), 'css() call should be erased in TSX file')
  assert(code.includes('"cls_'), 'should have cls_ class name')
})

test('two identical css({}) objects produce the same hash', () => {
  const src1 = `const a = css({ color: 'red', padding: '8px' })`
  const src2 = `const b = css({ color: 'red', padding: '8px' })`
  const r1 = transform('fileA.jsx', src1)
  const r2 = transform('fileB.jsx', src2)
  assert(r1.cssRules.length === 1 && r2.cssRules.length === 1, 'each file should produce 1 rule')
  assert(
    r1.cssRules[0].hash === r2.cssRules[0].hash,
    `hashes should match: ${r1.cssRules[0].hash} vs ${r2.cssRules[0].hash}`
  )
})

test('two different css({}) objects produce different hashes', () => {
  const src1 = `const a = css({ color: 'red' })`
  const src2 = `const b = css({ color: 'blue' })`
  const r1 = transform('fileA.jsx', src1)
  const r2 = transform('fileB.jsx', src2)
  assert(
    r1.cssRules[0].hash !== r2.cssRules[0].hash,
    'hashes should differ for different objects'
  )
})

test('integer numeric → Npx (no decimal point)', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ marginTop: 16 })`)
  assert(cssRules[0].css.includes('16px'), `got: ${cssRules[0].css}`)
  assert(!cssRules[0].css.includes('16.'), `should not have decimal, got: ${cssRules[0].css}`)
})

test('float numeric → N.Npx', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ letterSpacing: 1.5 })`)
  assert(cssRules[0].css.includes('1.5px'), `got: ${cssRules[0].css}`)
})

test('zero value → 0 (LightningCSS drops the px unit)', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ margin: 0 })`)
  assert(cssRules[0].css.includes('margin:0') || cssRules[0].css.includes('margin: 0'), `got: ${cssRules[0].css}`)
})

test('vendor-prefix property (WebkitAppearance) passes through LightningCSS', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ WebkitAppearance: 'none' })`)
  const css = cssRules[0].css
  assert(
    css.includes('appearance') || css.includes('-webkit-appearance'),
    `expected appearance property, got: ${css}`
  )
})

console.log('\n── Source map fields ──────────────────────────────────────────')

test('transform result has a map field', () => {
  const { map } = transform('test.jsx', `const x = css({ color: 'red' })`)
  assert(map === null || typeof map === 'string', `map should be null or string, got: ${typeof map}`)
})

test('css rule has a map field', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ color: 'red' })`)
  assert(cssRules.length === 1, 'expected 1 rule')
  const { map } = cssRules[0]
  assert(map === null || typeof map === 'string', `rule.map should be null or string, got: ${typeof map}`)
})

test('css rule map is valid JSON when present', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ color: 'red' })`)
  const { map } = cssRules[0]
  if (map !== null) {
    let parsed
    try { parsed = JSON.parse(map) } catch (e) { throw new Error(`rule.map is not valid JSON: ${e.message}`) }
    assert(parsed.version === 3, `expected source map version 3, got: ${parsed.version}`)
  }
})

// ─── v3 tests ────────────────────────────────────────────────────────────────

const THEME = JSON.stringify({
  colors: {
    primary: 'tomato',
    secondary: 'cyan',
  },
  spacing: {
    unit: 8,
  },
  typography: {
    fontFamily: 'Inter, sans-serif',
  },
})

console.log('\n── v3: Theming ────────────────────────────────────────────────')

test('css(({ theme }) => ({ color: theme.colors.primary })) — resolved to "tomato"', () => {
  const src = `const x = css(({ theme }) => ({ color: theme.colors.primary }))`
  const { code, cssRules } = transform('test.jsx', src, THEME)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('tomato'), `expected tomato in css, got: ${cssRules[0].css}`)
  assert(!code.includes('css('), `css() call should be erased, got: ${code}`)
  assert(code.includes('"cls_'), `expected cls_ class name, got: ${code}`)
})

test('css(({ theme }) => ({ fontSize: theme.spacing.unit * 4 })) — 32 → 32px', () => {
  const src = `const x = css(({ theme }) => ({ fontSize: theme.spacing.unit * 4 }))`
  const { cssRules } = transform('test.jsx', src, THEME)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('32px'), `expected 32px, got: ${cssRules[0].css}`)
})

test('theme member that does not exist → build error', () => {
  const src = `const x = css(({ theme }) => ({ color: theme.colors.nonexistent }))`
  assertThrows(
    () => transform('test.jsx', src, THEME),
    'nonexistent',
    'missing theme key should error'
  )
})

test('computed theme member (theme.colors[key]) → build error', () => {
  const src = `const x = css(({ theme }) => ({ color: theme.colors[dynamicKey] }))`
  assertThrows(
    () => transform('test.jsx', src, THEME),
    /computed/i,
    'computed member access should error'
  )
})

test('theme string concatenation with + operator', () => {
  const src = `const x = css(({ theme }) => ({ color: theme.colors.primary + ' !important' }))`
  const { cssRules } = transform('test.jsx', src, THEME)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('tomato'), `expected tomato in css, got: ${cssRules[0].css}`)
})

test('theme addition of two numbers', () => {
  const src = `const x = css(({ theme }) => ({ padding: theme.spacing.unit + 2 }))`
  const { cssRules } = transform('test.jsx', src, THEME)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('10px'), `expected 10px (8+2), got: ${cssRules[0].css}`)
})

test('theme without taiko — theme reference errors clearly', () => {
  const src = `const x = css(({ theme }) => ({ color: theme.colors.primary }))`
  assertThrows(
    () => transform('test.jsx', src, null),
    'theme',
    'missing theme object should error'
  )
})

console.log('\n── v3: globalCss tagged template ──────────────────────────────')

test('globalCss`body { margin: 0 }` — virtual global CSS module emitted', () => {
  const src = "globalCss`body { margin: 0; }`"
  const { code, globalCss } = transform('test.jsx', src)
  assert(globalCss.length === 1, `expected 1 globalCss rule, got ${globalCss.length}`)
  assert(globalCss[0].css.includes('margin'), `expected margin in css, got: ${globalCss[0].css}`)
  assert(globalCss[0].hash.length > 0, 'hash should be non-empty')
  // The call should be replaced with undefined
  assert(code.includes('undefined'), `expected undefined replacement, got: ${code}`)
})

test('globalCss with static interpolation — correctly concatenated', () => {
  const src = "const size = '16px'; globalCss`body { font-size: ${16}px; }`"
  const { globalCss } = transform('test.jsx', src)
  // The interpolation 16 is a numeric literal — should be concatenated
  assert(globalCss.length === 1, `expected 1 globalCss rule, got ${globalCss.length}`)
})

test('two identical globalCss bodies → same hash', () => {
  const r1 = transform('a.jsx', "globalCss`body { margin: 0; }`")
  const r2 = transform('b.jsx', "globalCss`body { margin: 0; }`")
  assert(r1.globalCss[0].hash === r2.globalCss[0].hash, 'same body → same hash')
})

console.log('\n── v3: keyframes tagged template ──────────────────────────────')

test('keyframes`from{opacity:0}to{opacity:1}` — virtual module, name returned', () => {
  const src = "const fadeIn = keyframes`from { opacity: 0; } to { opacity: 1; }`"
  const { code, keyframes } = transform('test.jsx', src)
  assert(keyframes.length === 1, `expected 1 keyframe rule, got ${keyframes.length}`)
  assert(keyframes[0].name.startsWith('kf_'), `expected kf_ prefix, got: ${keyframes[0].name}`)
  assert(keyframes[0].css.includes('@keyframes'), `expected @keyframes in css, got: ${keyframes[0].css}`)
  assert(keyframes[0].css.includes(keyframes[0].name), `css should contain the animation name`)
  // The tagged template should be replaced with the string name
  assert(code.includes(`"${keyframes[0].name}"`), `expected string literal "${keyframes[0].name}" in code, got: ${code}`)
})

test('keyframes name interpolated into css() — correctly resolved', () => {
  const src = `
    const fadeIn = keyframes\`from { opacity: 0; } to { opacity: 1; }\`
    const box = css({ animation: \`\${fadeIn} 0.5s ease-out\` })
  `
  const { code, cssRules, keyframes } = transform('test.jsx', src)
  assert(keyframes.length === 1, `expected 1 keyframe rule, got ${keyframes.length}`)
  assert(cssRules.length === 1, `expected 1 css rule, got ${cssRules.length}`)
  // The css rule should reference the kf_ name
  assert(cssRules[0].css.includes(keyframes[0].name),
    `expected ${keyframes[0].name} in css, got: ${cssRules[0].css}`)
})

test('two identical keyframes bodies → same hash, single virtual module', () => {
  const r1 = transform('a.jsx', "const a = keyframes`from { opacity: 0; } to { opacity: 1; }`")
  const r2 = transform('b.jsx', "const b = keyframes`from { opacity: 0; } to { opacity: 1; }`")
  assert(r1.keyframes[0].hash === r2.keyframes[0].hash, 'same body → same hash')
})

console.log('\n── v3: container queries ──────────────────────────────────────')

test('@container rule in css() object — passed through and minified', () => {
  const src = `const x = css({
    fontSize: '2rem',
    '@container (max-width: 768px)': { fontSize: '1.5rem' },
  })`
  const { cssRules } = transform('test.jsx', src)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.includes('@container'), `expected @container in css, got: ${cssRules[0].css}`)
})

test('named container query — passed through correctly', () => {
  const src = `const x = css({
    '@container sidebar (max-width: 300px)': { display: 'none' },
  })`
  const { cssRules } = transform('test.jsx', src)
  const css = cssRules[0].css
  assert(css.includes('sidebar'), `expected "sidebar" in css, got: ${css}`)
})

test('container() spread — expanded to container-type / container-name properties', () => {
  const src = `const sidebar = css({ ...container('sidebar', 'inline-size'), width: '250px' })`
  const { cssRules } = transform('test.jsx', src)
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  const css = cssRules[0].css
  // LightningCSS may shorthand container-type + container-name into
  // the container shorthand (e.g. "container:sidebar/inline-size")
  // — both forms are correct, so we check for the values rather than property names.
  assert(
    css.includes('container-type') || css.includes('container:') || css.includes('container :'),
    `expected container declaration in css, got: ${css}`
  )
  assert(css.includes('inline-size'), `expected inline-size in css, got: ${css}`)
  assert(css.includes('sidebar'), `expected sidebar in css, got: ${css}`)
})

test('container() with type only — emits container-type without container-name', () => {
  const src = `const x = css({ ...container('inline-size') })`
  const { cssRules } = transform('test.jsx', src)
  const css = cssRules[0].css
  assert(css.includes('container-type'), `expected container-type in css, got: ${css}`)
  assert(!css.includes('container-name'), `should NOT have container-name, got: ${css}`)
})

console.log('\n── v3: RTL direction ──────────────────────────────────────────')

test('dir option accepted — ltr produces css rule', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ paddingLeft: '8px' })`, null, 'ltr')
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.length > 0, 'expected non-empty css')
})

test('dir option accepted — rtl produces css rule', () => {
  const { cssRules } = transform('test.jsx', `const x = css({ paddingLeft: '8px' })`, null, 'rtl')
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
  assert(cssRules[0].css.length > 0, 'expected non-empty css')
})

test('no dir option defaults to ltr', () => {
  const r1 = transform('test.jsx', `const x = css({ color: 'red' })`)
  const r2 = transform('test.jsx', `const x = css({ color: 'red' })`, null, 'ltr')
  assert(r1.cssRules[0].css === r2.cssRules[0].css, 'default should match explicit ltr')
})

// ─── v4: Distribution layer ──────────────────────────────────────────────────

console.log('\n── v4: loader ─────────────────────────────────────────────────')

test('loader.cjs loads without error and exposes transform', () => {
  const binding = require('./loader.cjs')
  assert(typeof binding.transform === 'function', `transform should be a function, got: ${typeof binding.transform}`)
})

test('transform from loader.cjs produces a valid result', () => {
  const { transform: t } = require('./loader.cjs')
  const { code, cssRules } = t('test.jsx', `const x = css({ color: 'red' })`)
  assert(typeof code === 'string', 'code should be a string')
  assert(Array.isArray(cssRules), 'cssRules should be an array')
  assert(cssRules.length === 1, `expected 1 rule, got ${cssRules.length}`)
})

console.log('\n── v4: plugin.js ──────────────────────────────────────────────')

test('taiko() returns a plugin object with the required hooks', async () => {
  const { taiko } = await import('./plugin.js')
  const plugin = taiko()
  assert(typeof plugin.name === 'string', 'plugin.name should be a string')
  assert(plugin.enforce === 'pre', 'plugin.enforce should be "pre"')
  assert(typeof plugin.transform === 'function', 'plugin.transform should be a function')
  assert(typeof plugin.resolveId === 'function', 'plugin.resolveId should be a function')
  assert(typeof plugin.load === 'function', 'plugin.load should be a function')
  assert(typeof plugin.handleHotUpdate === 'function', 'plugin.handleHotUpdate should be a function')
  assert(typeof plugin.buildStart === 'function', 'plugin.buildStart should be a function')
})

test('taiko() with no arguments does not throw', async () => {
  const { taiko } = await import('./plugin.js')
  let threw = false
  try { taiko() } catch { threw = true }
  assert(!threw, 'taiko() with no args should not throw')
})

test('taiko({ theme }) passes theme through to transform — colour resolved in output', async () => {
  const { taiko } = await import('./plugin.js')
  const theme = { colors: { primary: 'tomato' } }
  const plugin = taiko({ theme })
  const src = `const x = css(({ theme }) => ({ color: theme.colors.primary }))`
  // Call the transform hook directly (simulate Vite)
  const result = plugin.transform(src, 'test.jsx')
  assert(result !== null && result !== undefined, 'expected a transform result, got null/undefined')
  assert(typeof result.code === 'string', 'result.code should be a string')
  assert(!result.code.includes('css('), 'css() call should be replaced')
  assert(result.code.includes('"cls_'), 'should contain a cls_ class name')
})

test('rustCssPlugin export is a valid plugin object', async () => {
  const { rustCssPlugin } = await import('./plugin.js')
  assert(typeof rustCssPlugin === 'object' && rustCssPlugin !== null, 'rustCssPlugin should be an object')
  assert(typeof rustCssPlugin.name === 'string', 'rustCssPlugin.name should be a string')
  assert(typeof rustCssPlugin.transform === 'function', 'rustCssPlugin.transform should be a function')
})

console.log('\n── v4: css shim (src/css.ts compiled) ─────────────────────────')

test('src/css.ts shim — css() returns an empty string', async () => {
  // Import the compiled JS shim (tsc must have run, or we test the TS source via tsx/ts-node)
  // We test the contract: the shim must return '' and not throw.
  // Dynamic import of a .ts file only works if tsx/ts-node is present;
  // guard gracefully if not available.
  let cssShim
  try {
    cssShim = await import('./src/css.ts')
  } catch {
    try {
      cssShim = await import('./src/css.js')
    } catch {
      console.log('    (skipped — shim not compiled yet; run tsc first)')
      return
    }
  }
  assert(typeof cssShim.css === 'function', 'css should be a function')
  assert(cssShim.css({ color: 'red' }) === '', 'css() shim should return ""')
  assert(typeof cssShim.globalCss === 'function', 'globalCss should be a function')
  assert(typeof cssShim.keyframes === 'function', 'keyframes should be a function')
  assert(typeof cssShim.container === 'function', 'container should be a function')
  assert(cssShim.keyframes`from{opacity:0}to{opacity:1}` === '', 'keyframes shim should return ""')
  const containerResult = cssShim.container('sidebar', 'inline-size')
  assert(typeof containerResult === 'object', 'container() shim should return an object')
})

console.log('\n── v4: check-platform.js ──────────────────────────────────────')

test('check-platform.js exits with code 0 on this platform', () => {
  const { execFileSync } = require('node:child_process')
  let exitCode = 0
  try {
    execFileSync(process.execPath, ['scripts/check-platform.js'], { encoding: 'utf8' })
  } catch (e) {
    exitCode = e.status ?? 1
  }
  assert(exitCode === 0, `check-platform.js exited with code ${exitCode}, expected 0`)
})

test('check-platform.js never throws on an unknown platform (env override)', () => {
  const { execFileSync } = require('node:child_process')
  let exitCode = 0
  try {
    execFileSync(process.execPath, ['scripts/check-platform.js'], {
      encoding: 'utf8',
      env: { ...process.env, MOCK_PLATFORM: 'freebsd-x64' },
    })
  } catch (e) {
    exitCode = e.status ?? 1
  }
  // Should always exit 0 — it warns, never errors
  assert(exitCode === 0, `check-platform.js should never exit non-zero, got ${exitCode}`)
})

// ─── v5: Runtime style overrides ────────────────────────────────────────────

console.log('\n── v5: Runtime — runtimeCss ────────────────────────────────────')

let runtimeMod
try {
  runtimeMod = await import('./src/runtime.ts')
} catch {
  try {
    runtimeMod = await import('./src/runtime.js')
  } catch {
    console.log('    (skipped — runtime module not compiled yet; run npm run build:ts first)')
  }
}

if (runtimeMod) {
  const { runtimeCss, runtimeGlobalCss, cx, _serializeCSS } = runtimeMod

  test('runtimeCss returns a class name matching stx_[a-f0-9]{8}', () => {
    const cls = runtimeCss({ color: 'red' })
    assert(/^stx_[a-f0-9]{8}$/.test(cls), `expected stx_<hash>, got: ${cls}`)
  })

  test('runtimeCss — camelCase → kebab-case', () => {
    const css = _serializeCSS('test', { backgroundColor: 'blue' })
    assert(css.includes('background-color'), `expected background-color, got: ${css}`)
  })

  test('runtimeCss — number value gets px suffix', () => {
    const css = _serializeCSS('test', { padding: 16 })
    assert(css.includes('padding:16px'), `expected padding:16px, got: ${css}`)
  })

  test('runtimeCss — unitless opacity gets no px', () => {
    const css = _serializeCSS('test', { opacity: 0.5 })
    assert(!css.includes('px'), `expected no px, got: ${css}`)
    assert(css.includes('0.5'), `expected 0.5, got: ${css}`)
  })

  test('runtimeCss — unitless fontWeight gets no px', () => {
    const css = _serializeCSS('test', { fontWeight: 700 })
    assert(!css.includes('px'), `expected no px, got: ${css}`)
    assert(css.includes('700'), `expected 700, got: ${css}`)
  })

  test('runtimeCss — zero value gets no px', () => {
    const css = _serializeCSS('test', { margin: 0 })
    assert(css.includes('margin:0'), `expected margin:0, got: ${css}`)
    assert(!css.includes('0px'), `expected no 0px, got: ${css}`)
  })

  test('runtimeCss — float gets px suffix', () => {
    const css = _serializeCSS('test', { letterSpacing: 1.5 })
    assert(css.includes('1.5px'), `expected 1.5px, got: ${css}`)
  })

  test('runtimeCss — string value passes through', () => {
    const css = _serializeCSS('test', { color: 'red' })
    assert(css.includes('color:red'), `expected color:red, got: ${css}`)
  })

  test('runtimeCss — &:hover nesting', () => {
    const css = _serializeCSS('test', {
      color: 'red',
      '&:hover': { color: 'blue' },
    })
    assert(css.includes(':hover'), `expected :hover, got: ${css}`)
    assert(css.includes('color:blue'), `expected color:blue, got: ${css}`)
  })

  test('runtimeCss — @media query', () => {
    const css = _serializeCSS('test', {
      padding: 16,
      '@media (max-width: 600px)': { padding: 8 },
    })
    assert(css.includes('@media'), `expected @media, got: ${css}`)
    assert(css.includes('8px'), `expected 8px, got: ${css}`)
  })

  test('runtimeCss — @container query', () => {
    const css = _serializeCSS('test', {
      '@container (min-width: 400px)': { display: 'flex' },
    })
    assert(css.includes('@container'), `expected @container, got: ${css}`)
    assert(css.includes('display:flex'), `expected display:flex, got: ${css}`)
  })

  test('runtimeCss — same input produces same class name', () => {
    const a = runtimeCss({ color: 'tomato', padding: 8 })
    const b = runtimeCss({ color: 'tomato', padding: 8 })
    assert(a === b, `expected same class name, got: ${a} vs ${b}`)
  })

  test('runtimeCss — different input produces different class name', () => {
    const a = runtimeCss({ color: 'tomato' })
    const b = runtimeCss({ color: 'cyan' })
    assert(a !== b, `expected different class names, got: ${a} vs ${b}`)
  })

  test('runtimeCss — deeply nested selectors', () => {
    const css = _serializeCSS('test', {
      '&:disabled': {
        opacity: 0.5,
        cursor: 'not-allowed',
      },
    })
    assert(css.includes(':disabled'), `expected :disabled, got: ${css}`)
    assert(css.includes('cursor:not-allowed'), `expected cursor:not-allowed, got: ${css}`)
  })

  test('runtimeCss — multiple declarations', () => {
    const css = _serializeCSS('test', {
      backgroundColor: 'red',
      padding: 16,
      borderRadius: 4,
    })
    assert(css.includes('background-color:red'), `expected background-color:red, got: ${css}`)
    assert(css.includes('padding:16px'), `expected padding:16px, got: ${css}`)
    assert(css.includes('border-radius:4px'), `expected border-radius:4px, got: ${css}`)
  })

  test('runtimeCss — null and undefined values are skipped', () => {
    const css = _serializeCSS('test', { color: 'red', padding: null, margin: undefined })
    assert(css.includes('color:red'), `expected color:red, got: ${css}`)
    assert(!css.includes('padding'), `expected no padding, got: ${css}`)
    assert(!css.includes('margin'), `expected no margin, got: ${css}`)
  })

  console.log('\n── v5: Runtime — runtimeGlobalCss ──────────────────────────────')

  test('runtimeGlobalCss — serializes selector-wrapped CSS', () => {
    // We can't easily test DOM injection in Node, but we can test that it doesn't throw
    let threw = false
    try {
      runtimeGlobalCss({ body: { margin: 0 } })
    } catch {
      threw = true
    }
    assert(!threw, 'runtimeGlobalCss should not throw in Node (SSR safe)')
  })

  console.log('\n── v5: Runtime — cx ────────────────────────────────────────────')

  test('cx — joins strings with spaces', () => {
    assert(cx('a', 'b') === 'a b', `expected "a b", got: "${cx('a', 'b')}"`)
  })

  test('cx — filters falsy values', () => {
    const result = cx('a', false, 'b', undefined, null, 'c')
    assert(result === 'a b c', `expected "a b c", got: "${result}"`)
  })

  test('cx — empty args returns empty string', () => {
    assert(cx() === '', `expected "", got: "${cx()}"`)
  })

  test('cx — single arg returns the arg', () => {
    assert(cx('only') === 'only', `expected "only", got: "${cx('only')}"`)
  })

  test('cx — all falsy returns empty string', () => {
    assert(cx(false, null, undefined, 0, '') === '', `expected "", got: "${cx(false, null, undefined, 0, '')}"`)
  })
}

// ─── summary ────────────────────────────────────────────────────────────────

await Promise.all(pending)

console.log(`\n${'─'.repeat(55)}`)
console.log(`  ${passed} passed, ${failed} failed`)
if (failed > 0) process.exit(1)

