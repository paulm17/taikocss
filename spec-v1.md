# Zero-Runtime CSS-in-JS Engine: Taikocss
## Technical Specification: Rust + OXC + LightningCSS + Vite

---

## Overview

A high-performance, zero-runtime CSS-in-JS extraction tool that allows developers to write object-syntax CSS (`css({ color: 'red' })`) inside React components. The engine extracts these objects at **build time**, compiles them to static CSS, and replaces the JavaScript call with a hashed class name.

This is the same architecture used by **Tailwind v4**: a Rust core compiled to a native `.node` binary via NAPI-RS, loaded by a minimal JS shim that registers it as a Vite plugin. All logic lives in Rust.

### Constraints

- Core engine written in Rust.
- JavaScript parsing uses **OXC** (Oxidation Compiler).
- CSS processing, nesting, and minification uses **LightningCSS**.
- Integrates with Vite via a minimal JS shim (~10 lines) — no TypeScript, no plugin framework.
- No runtime CSS-in-JS libraries.

---

## Architecture

```
vite dev / vite build
        │
        ▼
  vite.config.js         ← ~10 lines of JS. Just loads the binary and registers hooks.
        │
        ▼
  my-css-engine.node     ← Compiled Rust binary (NAPI-RS)
  ┌─────────────────────────────────────────┐
  │                                         │
  │  ┌──────────┐      ┌────────────────┐   │
  │  │   OXC    │ ───► │  LightningCSS  │   │
  │  │  Parser  │      │   Processor    │   │
  │  └──────────┘      └────────────────┘   │
  │  Parse AST          Lower syntax        │
  │  Find css({})       Add prefixes        │
  │  Extract objects    Minify              │
  │  Mutate AST         Generate hash       │
  │  Codegen JS                             │
  └─────────────────────────────────────────┘
        │                    │
        ▼                    ▼
  Modified JS           CSS Rules
        │                    │
        └──────────┬──────────┘
                   ▼
          Vite virtual modules
                   │
                   ▼
        Browser gets:
        className="cls_a3f9b2c1" + static .css
```

---

## Part 1: Rust Core

### Project Structure

```
my-css-engine/
├── Cargo.toml
├── src/
│   └── lib.rs
├── index.js            ← generated by NAPI-RS build
└── my-css-engine.node  ← compiled native binary
```

### `Cargo.toml`

```toml
[package]
name = "my-css-engine"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
napi        = { version = "2", features = ["napi4"] }
napi-derive = "2"

# OXC — JavaScript parsing
oxc_allocator = "0.10"
oxc_parser    = "0.10"
oxc_span      = "0.10"
oxc_ast       = "0.10"
oxc_codegen   = "0.10"

# LightningCSS — CSS processing
lightningcss = { version = "1.0.0-alpha.58", features = ["napi"] }
```

No SHA crates needed — LightningCSS generates the class name hash internally via its CSS Modules implementation.

---

### Exported Function

```rust
// Exposed to Node.js / Vite via NAPI-RS
transform(filename: String, source_code: String) -> TransformResult
```

```rust
pub struct TransformResult {
    pub code: String,          // Modified JS — css({}) replaced by "cls_xyz"
    pub css_rules: Vec<CssRule>,
}

pub struct CssRule {
    pub hash: String,          // e.g. "a3f9b2c1"
    pub css: String,           // e.g. ".cls_a3f9b2c1{color:red}"
}
```

---

### 1.1 — OXC Parsing

- Initialize `oxc_allocator` (arena allocator — fast, no GC pressure).
- Parse `source_code` into an AST via `SourceType::from_path(&filename)`.
- Traverse AST looking for `CallExpression` where callee is `Identifier` named `css`.
- Extract the first argument — must be an `ObjectExpression`.
- **On parse error:** return original source code untouched.

### 1.2 — Object → Raw CSS String

Recursively process the `ObjectExpression`:

| Input | Output |
|---|---|
| `camelCase` keys | `kebab-case` |
| `StringLiteral` values | raw string |
| `NumericLiteral` values | append `px` unless property is in the unitless whitelist |
| Nested `ObjectExpression` (`&:hover`, `@media`) | Recursive → nested block |
| Dynamic runtime variable | Skip silently OR throw: *"Only static values are supported"* |

**Unitless property whitelist** — numbers on these properties are kept as raw strings with no `px` appended:

```rust
const UNITLESS: &[&str] = &[
    "opacity", "z-index", "line-height", "flex", "flex-grow",
    "flex-shrink", "order", "font-weight", "tab-size", "orphans",
    "widows", "counter-increment", "counter-reset",
];
```

For all other properties, a `NumericLiteral` value is converted by appending `px` — e.g. `padding: 16` → `padding: 16px`.

Output is a raw CSS string wrapped in a dummy class `.css_obj { ... }` — **not** a bare `&` selector. LightningCSS's `StyleSheet::parse` will fail on a root-level `&`. The dummy class is what CSS Modules hashes:

```css
.css_obj { background-color: oklch(60% 0.2 250); padding: 8px 16px; &:hover { color: red; } }
```

LightningCSS's CSS Modules feature automatically hashes `.css_obj` into a unique scoped name (e.g. `cls_a3f9b2c1`) and returns it in the `exports` map. That exported name is what replaces the original `css({...})` call in the JS.

### 1.3 — LightningCSS Processing

```rust
use lightningcss::stylesheet::{StyleSheet, ParserOptions, PrinterOptions, MinifyOptions};
use lightningcss::targets::{Targets, Browsers};
```

Pipeline:

1. **Parse** `StyleSheet::parse(&raw_css, ParserOptions { css_modules: true, .. })`
   - `css_modules: true` — LightningCSS scopes and hashes the class name automatically.
2. **Minify** `stylesheet.minify(MinifyOptions::default())`
   - Flattens nesting, removes redundancy.
3. **Print** `stylesheet.to_css(PrinterOptions { minify: true, targets, .. })`
   - Lowers `oklch()`, custom media, nesting to browser-compatible CSS.
   - Adds vendor prefixes.

**Default browser targets:**

```rust
let targets = Targets {
    browsers: Some(Browsers {
        chrome: Some(100 << 16),  // Chrome 100
        safari: Some(15 << 16),   // Safari 15
        ..Browsers::default()
    }),
    ..Targets::default()
};
```

LightningCSS returns both the final CSS string and the generated scoped class name. No manual hashing needed.

### 1.4 — AST Mutation & Codegen

1. **Mutate:** Replace the `css({ ... })` `CallExpression` in the OXC AST with a `StringLiteral` of the LightningCSS class name.
2. **Codegen:** `oxc_codegen::CodeGenerator` prints the modified AST back to a JS string.
3. **Return:** `TransformResult { code, css_rules }`.

---

## Part 2: Vite Glue (JS shim)

This is the only JavaScript in the project. It does no logic — it loads the binary and wires up Vite's hooks.

### `vite.config.js`

```js
import { createRequire } from 'module'

const require = createRequire(import.meta.url)
const { transform } = require('./my-css-engine/index.js') // loads .node binary

const cssMap = new Map()

const rustCssPlugin = {
  name: 'rust-css',
  enforce: 'pre',

  transform(code, id) {
    if (!/\.(t|j)sx?$/.test(id) || id.includes('node_modules')) return
    if (!code.includes('css(')) return

    const result = transform(id, code)
    if (!result.cssRules.length) return

    let imports = ''
    for (const rule of result.cssRules) {
      const vid = `virtual:css/${rule.hash}.css`
      cssMap.set(vid, rule.css)
      imports += `import "${vid}";\n`
    }

    return { code: imports + result.code, map: null }
  },

  resolveId(id) {
    if (id.startsWith('virtual:css/')) return id
  },

  load(id) {
    if (id.startsWith('virtual:css/')) return cssMap.get(id)
  }
}

export default {
  plugins: [rustCssPlugin]
}
```

---

## Part 3: Usage Example

### Input (developer writes this)

```jsx
import { css } from './css' // no-op shim at runtime; erased at build time

const button = css({
  backgroundColor: 'oklch(60% 0.2 250)',
  padding: '8px 16px',
  borderRadius: '4px',
  '&:hover': {
    backgroundColor: 'oklch(50% 0.2 250)',
  },
  '@media (max-width: 600px)': {
    padding: '4px 8px',
  },
})

export function Button() {
  return <button className={button}>Click me</button>
}
```

### Output JS (after Rust transform)

```jsx
const button = "cls_a3f9b2c1"

export function Button() {
  return <button className={button}>Click me</button>
}
```

### Output CSS (injected via virtual module)

```css
.cls_a3f9b2c1{background-color:#3a6fd8;padding:8px 16px;border-radius:4px}
.cls_a3f9b2c1:hover{background-color:#2d57b0}
@media (max-width:600px){.cls_a3f9b2c1{padding:4px 8px}}
```

---

## Edge Cases

| Scenario | Behaviour |
|---|---|
| Dynamic variable (`color: myVar`) | Skip property silently OR throw descriptive build error |
| OXC parse failure | Return original source untouched |
| No `css()` calls in file | Early bail-out, Rust binary not called |
| Nested objects (`&:hover`, `@media`) | Recursive extraction, fully supported |
| Numeric values (`fontSize: 16`) | Converted to `font-size: 16px` (unitless whitelist excepted) |

---

## Build

```bash
# Install NAPI-RS CLI once
npm install -g @napi-rs/cli

# Build the native binary for your current platform
npm run build

# Outputs:
#   index.js             — thin JS loader (generated, don't edit)
#   my-css-engine.node   — native binary called by Vite
```