#![deny(clippy::all)]

use napi_derive::napi;
use napi::bindgen_prelude::*;

use std::path::Path;

use oxc_allocator::Allocator;
use oxc_parser::{Parser, ParseOptions, ParserReturn};
use oxc_span::{SourceType, GetSpan};
use oxc_ast::ast::*;
use oxc_codegen::{Codegen, CodegenOptions};

use lightningcss::stylesheet::{StyleSheet, ParserOptions, PrinterOptions, MinifyOptions};
use lightningcss::targets::{Targets, Browsers};

use parcel_sourcemap::SourceMap;

// ---------------------------------------------------------------------------
// Public types exposed to Node.js via NAPI-RS
// ---------------------------------------------------------------------------

#[napi(object)]
pub struct ExtractedCssRule {
    pub hash: String,
    pub css: String,
    /// V3 source map JSON for the generated CSS, if source map generation
    /// succeeded. Attach to the virtual CSS module as a
    /// `/*# sourceMappingURL=data:…;base64,… */` comment or serve as a
    /// separate `.map` file.
    pub map: Option<String>,
}

#[napi(object)]
pub struct TransformResult {
    pub code: String,
    pub css_rules: Vec<ExtractedCssRule>,
    /// V3 source map JSON for the transformed JS. Generated by oxc_codegen
    /// from the original AST; covers all unchanged tokens perfectly.  The
    /// Vite plugin should pass this through as `{ code, map }` so that Vite
    /// can chain it with any upstream maps.
    pub map: Option<String>,
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

const UNITLESS: &[&str] = &[
    "opacity",
    "z-index",
    "line-height",
    "flex",
    "flex-grow",
    "flex-shrink",
    "order",
    "font-weight",
    "tab-size",
    "orphans",
    "widows",
    "counter-increment",
    "counter-reset",
];

// ---------------------------------------------------------------------------
// camelCase → kebab-case
// ---------------------------------------------------------------------------

fn camel_to_kebab(s: &str) -> String {
    let mut out = String::with_capacity(s.len() + 4);
    for ch in s.chars() {
        if ch.is_uppercase() {
            out.push('-');
            out.push(ch.to_lowercase().next().unwrap());
        } else {
            out.push(ch);
        }
    }
    out
}

// ---------------------------------------------------------------------------
// Simple 32-bit hash (FNV-1a) of a string → 8 hex chars
// We hash the raw CSS content so identical objects produce the same class name
// and different objects always produce different ones, without relying on
// LightningCSS CSS Modules (which hashes the *filename*, not the content).
// ---------------------------------------------------------------------------

fn hash_css(s: &str) -> String {
    let mut h: u32 = 0x811c9dc5;
    for byte in s.bytes() {
        h ^= byte as u32;
        h = h.wrapping_mul(0x01000193);
    }
    format!("{:08x}", h)
}

// ---------------------------------------------------------------------------
// Convert a byte offset into a 1-based (line, col) pair.
// Scans the source once; cheap for typical file sizes.
// ---------------------------------------------------------------------------

fn byte_offset_to_line_col(source: &str, offset: u32) -> (u32, u32) {
    let offset = offset as usize;
    let mut line: u32 = 1;
    let mut line_start: usize = 0;

    for (i, ch) in source.char_indices() {
        if i >= offset {
            break;
        }
        if ch == '\n' {
            line += 1;
            line_start = i + 1;
        }
    }

    let col = (offset - line_start) as u32 + 1;
    (line, col)
}

// ---------------------------------------------------------------------------
// ObjectExpression → raw CSS string (recursive)
//
// `filename` and `source` are threaded through so that every error message
// can include the exact file path and 1-based line:col of the offending node.
// ---------------------------------------------------------------------------

fn object_to_css(
    obj: &ObjectExpression,
    indent: usize,
    filename: &str,
    source: &str,
) -> Result<String> {
    let pad = "  ".repeat(indent);
    let mut css = String::new();

    for prop in &obj.properties {
        match prop {
            ObjectPropertyKind::ObjectProperty(p) => {
                let key_str: String = match &p.key {
                    PropertyKey::StringLiteral(s) => s.value.to_string(),
                    PropertyKey::StaticIdentifier(id) => id.name.to_string(),
                    other => {
                        let (line, col) = byte_offset_to_line_col(source, other.span().start);
                        return Err(Error::new(
                            Status::InvalidArg,
                            format!(
                                "{}:{}:{}: css() — computed/private property keys are not \
                                 supported.\n\
                                 Hint: use a plain string or identifier as the property name.",
                                filename, line, col
                            ),
                        ));
                    }
                };

                match &p.value {
                    Expression::ObjectExpression(nested_obj) => {
                        let nested_css = object_to_css(nested_obj, indent + 1, filename, source)?;
                        css.push_str(&format!(
                            "{}{} {{\n{}{}}}\n",
                            pad, key_str, nested_css, pad
                        ));
                    }
                    Expression::StringLiteral(s) => {
                        let prop_name = camel_to_kebab(&key_str);
                        css.push_str(&format!("{}{}: {};\n", pad, prop_name, s.value));
                    }
                    Expression::NumericLiteral(n) => {
                        let prop_name = camel_to_kebab(&key_str);
                        if UNITLESS.contains(&prop_name.as_str()) {
                            css.push_str(&format!("{}{}: {};\n", pad, prop_name, n.value));
                        } else if n.value.fract() == 0.0 {
                            css.push_str(&format!(
                                "{}{}: {}px;\n",
                                pad, prop_name, n.value as i64
                            ));
                        } else {
                            css.push_str(&format!("{}{}: {}px;\n", pad, prop_name, n.value));
                        }
                    }
                    other => {
                        // Dynamic value — emit a rich diagnostic pointing at the value node.
                        let (line, col) = byte_offset_to_line_col(source, other.span().start);
                        return Err(Error::new(
                            Status::InvalidArg,
                            format!(
                                "{}:{}:{}: css() — only static values are supported \
                                 (property: '{}').\n\
                                 Hint: extract the value to a constant or use a CSS variable.",
                                filename, line, col, key_str
                            ),
                        ));
                    }
                }
            }
            ObjectPropertyKind::SpreadProperty(spread) => {
                let (line, col) = byte_offset_to_line_col(source, spread.span.start);
                return Err(Error::new(
                    Status::InvalidArg,
                    format!(
                        "{}:{}:{}: css() — spread properties are not supported.\n\
                         Hint: inline the spread object's properties directly into this css() call.",
                        filename, line, col
                    ),
                ));
            }
        }
    }

    Ok(css)
}

// ---------------------------------------------------------------------------
// Process one css({}) argument → (class_name, minified_css, optional_css_map)
// ---------------------------------------------------------------------------

fn process_css_object(
    obj: &ObjectExpression,
    filename: &str,
    source: &str,
) -> Result<(String, String, Option<String>)> {
    // 1. Build raw CSS using a placeholder class name
    let inner = object_to_css(obj, 1, filename, source)?;
    let raw_css = format!(".css_obj {{\n{}}}\n", inner);

    // 2. Hash the raw CSS content to produce a stable, unique class name
    let hash = hash_css(&raw_css);
    let class_name = format!("cls_{}", hash);

    // 3. Browser targets for syntax lowering
    let targets = Targets {
        browsers: Some(Browsers {
            chrome: Some(100 << 16),
            safari: Some(15 << 16),
            ..Browsers::default()
        }),
        ..Targets::default()
    };

    // 4. Parse with LightningCSS (no CSS Modules — we handle naming ourselves)
    let parser_options = ParserOptions::default();

    let mut stylesheet = StyleSheet::parse(&raw_css, parser_options).map_err(|e| {
        Error::new(
            Status::GenericFailure,
            format!("{}: LightningCSS parse error: {}", filename, e),
        )
    })?;

    // 5. Minify
    stylesheet.minify(MinifyOptions::default()).map_err(|e| {
        Error::new(
            Status::GenericFailure,
            format!("{}: LightningCSS minify error: {:?}", filename, e),
        )
    })?;

    // 6. Build a parcel SourceMap to thread through the printer.
    //    The project root is set to "/" so that paths in the map are relative
    //    (the virtual CSS module has no real path on disk).
    let mut css_source_map = SourceMap::new("/");

    // 7. Print / lower syntax (oklch → hex, nesting → expanded, vendor prefixes)
    //    Pass the source map object into PrinterOptions so LightningCSS
    //    populates it with selector-level mappings.
    let printer_options = PrinterOptions {
        minify: true,
        targets,
        source_map: Some(&mut css_source_map),
        ..PrinterOptions::default()
    };

    let result = stylesheet.to_css(printer_options).map_err(|e| {
        Error::new(
            Status::GenericFailure,
            format!("{}: LightningCSS print error: {:?}", filename, e),
        )
    })?;

    // 8. Replace the placeholder class name with our content-hashed one
    let final_css = result.code.replace(".css_obj", &format!(".{}", class_name));

    // 9. Serialize the source map to a JSON string.  We set the source
    //    content inline so DevTools can display the original CSS without a
    //    network round-trip.
    let css_map_json = css_source_map
        .to_json(None)
        .ok()
        .map(|json| json.to_string());

    Ok((class_name, final_css, css_map_json))
}

// ---------------------------------------------------------------------------
// Main NAPI export
// ---------------------------------------------------------------------------

#[napi]
pub fn transform(filename: String, source_code: String) -> Result<TransformResult> {
    let allocator = Allocator::default();
    let source_type = SourceType::from_path(&filename).unwrap_or_default();

    let ParserReturn { program, errors, panicked, .. } =
        Parser::new(&allocator, &source_code, source_type)
            .with_options(ParseOptions::default())
            .parse();

    if panicked || !errors.is_empty() {
        return Ok(TransformResult { code: source_code, css_rules: vec![], map: None });
    }

    // Collect (byte_start, byte_end, class_name) for every css({}) call, and
    // the corresponding CSS rule (with its own source map).
    let mut replacements: Vec<(u32, u32, String)> = vec![];
    let mut css_rules: Vec<ExtractedCssRule> = vec![];

    for stmt in &program.body {
        walk_statement(stmt, &mut replacements, &mut css_rules, &filename, &source_code)?;
    }

    if replacements.is_empty() {
        return Ok(TransformResult { code: source_code, css_rules: vec![], map: None });
    }

    // JS source map: run codegen on the original AST to get a correct V3 map.
    // Codegen reprints with its own whitespace so its byte offsets differ from
    // the original source. We therefore keep the two operations separate:
    //   - Source map  -> from codegen (correct for all unchanged tokens)
    //   - Code output -> byte-range replacements on the *original* source string
    //     (where OXC span offsets are correct), same as before source maps were added.
    let js_map: Option<String> = Codegen::new()
        .with_options(CodegenOptions {
            source_map_path: Some(Path::new(&filename).into()),
            ..CodegenOptions::default()
        })
        .with_source_text(&source_code)
        .build(&program)
        .map
        .map(|sm| sm.to_json_string());

    // Apply byte-range replacements to the original source (spans are correct here).
    let mut output = source_code.clone();
    replacements.sort_by(|a, b| b.0.cmp(&a.0));
    for (start, end, class_name) in &replacements {
        output.replace_range(
            (*start as usize)..(*end as usize),
            &format!("\"{}\"", class_name),
        );
    }

    Ok(TransformResult { code: output, css_rules, map: js_map })
}

// ---------------------------------------------------------------------------
// AST walkers
// ---------------------------------------------------------------------------

fn walk_statement<'a>(
    stmt: &Statement<'a>,
    replacements: &mut Vec<(u32, u32, String)>,
    css_rules: &mut Vec<ExtractedCssRule>,
    filename: &str,
    source: &str,
) -> Result<()> {
    match stmt {
        Statement::ExpressionStatement(es) => {
            walk_expression(&es.expression, replacements, css_rules, filename, source)?;
        }
        Statement::VariableDeclaration(vd) => {
            for decl in &vd.declarations {
                if let Some(init) = &decl.init {
                    walk_expression(init, replacements, css_rules, filename, source)?;
                }
            }
        }
        Statement::ReturnStatement(rs) => {
            if let Some(arg) = &rs.argument {
                walk_expression(arg, replacements, css_rules, filename, source)?;
            }
        }
        Statement::BlockStatement(bs) => {
            for s in &bs.body {
                walk_statement(s, replacements, css_rules, filename, source)?;
            }
        }
        Statement::FunctionDeclaration(fd) => {
            if let Some(body) = &fd.body {
                for s in &body.statements {
                    walk_statement(s, replacements, css_rules, filename, source)?;
                }
            }
        }
        Statement::ExportNamedDeclaration(en) => {
            if let Some(decl) = &en.declaration {
                walk_declaration(decl, replacements, css_rules, filename, source)?;
            }
        }
        Statement::ExportDefaultDeclaration(ed) => {
            if let Some(expr) = ed.declaration.as_expression() {
                walk_expression(expr, replacements, css_rules, filename, source)?;
            } else if let ExportDefaultDeclarationKind::FunctionDeclaration(fd) = &ed.declaration {
                if let Some(body) = &fd.body {
                    for s in &body.statements {
                        walk_statement(s, replacements, css_rules, filename, source)?;
                    }
                }
            }
        }
        Statement::IfStatement(is_stmt) => {
            walk_statement(&is_stmt.consequent, replacements, css_rules, filename, source)?;
            if let Some(alt) = &is_stmt.alternate {
                walk_statement(alt, replacements, css_rules, filename, source)?;
            }
        }
        _ => {}
    }
    Ok(())
}

fn walk_declaration<'a>(
    decl: &Declaration<'a>,
    replacements: &mut Vec<(u32, u32, String)>,
    css_rules: &mut Vec<ExtractedCssRule>,
    filename: &str,
    source: &str,
) -> Result<()> {
    match decl {
        Declaration::VariableDeclaration(vd) => {
            for d in &vd.declarations {
                if let Some(init) = &d.init {
                    walk_expression(init, replacements, css_rules, filename, source)?;
                }
            }
        }
        Declaration::FunctionDeclaration(fd) => {
            if let Some(body) = &fd.body {
                for s in &body.statements {
                    walk_statement(s, replacements, css_rules, filename, source)?;
                }
            }
        }
        _ => {}
    }
    Ok(())
}

fn walk_expression<'a>(
    expr: &Expression<'a>,
    replacements: &mut Vec<(u32, u32, String)>,
    css_rules: &mut Vec<ExtractedCssRule>,
    filename: &str,
    source: &str,
) -> Result<()> {
    match expr {
        Expression::CallExpression(call) => {
            let is_css_call = matches!(
                &call.callee,
                Expression::Identifier(id) if id.name.as_str() == "css"
            );

            if is_css_call {
                if let Some(first_arg) = call.arguments.first() {
                    if let Some(Expression::ObjectExpression(obj)) = first_arg.as_expression() {
                        match process_css_object(obj, filename, source) {
                            Ok((class_name, css_text, css_map)) => {
                                replacements.push((call.span.start, call.span.end, class_name.clone()));
                                let hash = class_name.strip_prefix("cls_").unwrap_or(&class_name).to_string();
                                css_rules.push(ExtractedCssRule { hash, css: css_text, map: css_map });
                                return Ok(());
                            }
                            Err(e) => return Err(e),
                        }
                    }
                }
            }

            walk_expression(&call.callee, replacements, css_rules, filename, source)?;
            for arg in &call.arguments {
                if let Some(e) = arg.as_expression() {
                    walk_expression(e, replacements, css_rules, filename, source)?;
                }
            }
        }

        Expression::ArrowFunctionExpression(arrow) => {
            for s in &arrow.body.statements {
                walk_statement(s, replacements, css_rules, filename, source)?;
            }
        }

        Expression::JSXElement(el) => {
            for attr in &el.opening_element.attributes {
                if let JSXAttributeItem::Attribute(a) = attr {
                    if let Some(JSXAttributeValue::ExpressionContainer(ec)) = &a.value {
                        if let Some(e) = ec.expression.as_expression() {
                            walk_expression(e, replacements, css_rules, filename, source)?;
                        }
                    }
                }
            }
            for child in &el.children {
                if let JSXChild::ExpressionContainer(ec) = child {
                    if let Some(e) = ec.expression.as_expression() {
                        walk_expression(e, replacements, css_rules, filename, source)?;
                    }
                }
            }
        }

        Expression::ParenthesizedExpression(pe) => {
            walk_expression(&pe.expression, replacements, css_rules, filename, source)?;
        }

        _ => {}
    }
    Ok(())
}